---
title: "Capitolo 4"
output: html_notebook
---

capitolo 4
```{r Import_r_Package}
library(rethinking)
```

```{python Import_Python_Package}
import numpy as np

```


```{r 4.1}
pos <- replicate( 1000 , sum( runif(16,-1,1) ) )
```

```{r 4.2}
prod(runif(100,0,0.1))
```

importo i dati dal pacchetto *rethinking*
```{r 4.7}
data("Howell1")
d <- Howell1
```


```{r 4.8}
str(d)
```


```{r 4.9}
d2 <- d[d$age>=18,]
```


```{r 4.14}
mu.list <- seq(from=140, to= 160, length.out = 200)
sigma.list <- seq(from=4, to= 9, length.out = 200)
post <- expand.grid(mu=mu.list,sigma=sigma.list)

post$LL <- sapply(1:nrow(post),
                  function(i) sum(
                    dnorm(d2$height,
                          mean = post$mu[i],
                          sd= post$sigma[i],
                          log=TRUE)
                  ))

# per il calcolod della verosmiglianza
post$prod <- post$LL + dnorm(post$mu,178,20,TRUE)+dunif(post$sigma,0,50,TRUE)
post$prob <- exp(post$prod-max(post$prod))
```

questa parte di codice serve per impedire che la trasformazione esponenziale mi restituisca tutti zeri, quando calcolo la probabilità a posteriori.ma la probabilità che ottengo così facendo non è una probabilità reale, ma una relativa. 
```{r eval=FALSE}
post$prob <- exp(post$prod-max(post$prod)) 
```



```{r 4.15}
contour_xyz(post$mu,post$sigma,post$prob)
```


```{r 4.16}
image_xyz(post$mu,post$sigma,post$prob)
```


```{r 4.17}
sample.row <- sample(1:nrow(post),size = 1e6,replace = TRUE,prob = post$prob)
sample.mu <- post$mu[sample.row]
sample.sigma <- post$sigma[sample.row]
```


```{r 4.18}
plot(sample.mu,sample.sigma, cex=0.5, pch=16, col=col.alpha(rangi2,0.013),xlab="mu",ylab="sigma")
```


```{r 4.19}
dens(sample.mu)
dens(sample.sigma)
```


```{r 4.20}
HPDI(sample.mu)
HPDI(sample.sigma)
```

```{r 4.21}
d3 <- sample(d2$height,size = 20)
```

```{r}
mu.list <- seq(from=140, to= 160, length.out = 200)
sigma.list <- seq(from=4, to= 20, length.out = 200)

post2 <- expand.grid(mu=mu.list,sigma=sigma.list)

post2$LL <- sapply(1:nrow(post2),
                  function(i) sum(
                    dnorm(d3,
                          mean = post$mu[i],
                          sd= post$sigma[i],
                          log=TRUE)
                  ))

# per il calcolod della verosmiglianza
post2$prod <- post2$LL + dnorm(post2$mu,178,20,TRUE)+dunif(post2$sigma,0,50,TRUE)
post2$prob <- exp(post2$prod-max(post2$prod))

sample2.row <- sample(1:nrow(post2),size = 1e4,replace = TRUE,prob = post2$prob)
sample2.mu <- post2$mu[sample.row]
sample2.sigma <- post2$sigma[sample.row]

plot(sample2.mu,sample2.sigma, cex=0.5, pch=16, col=col.alpha(rangi2,0.013),xlab="mu",ylab="sigma")
```


```{r 4.23}
dens(sample2.sigma,norm.comp = TRUE)
```


```{r 4.25}
flist <- alist(
  height~dnorm(mu,sigma),
  mu ~ dnorm(178,20),
  sigma~dunif(0,50)
)
```

```{r 4.26}
m4.1 <- map(flist,data = d2)
```


```{r 4.27}
precis(m4.1)
```

```{r 4.28}
start <- list(
  mu=mean(d2$height),
  sigma=sd(d2$height)
)
```


```{r 4.29}
m4.2 <- map(
  alist(
    height~dnorm(mu,sigma),
    mu ~ dnorm(178,0.1),
    sigma~dunif(0,50)
  ),
  data = d2)

precis(m4.2)
```


```{r 4.30}
vcov(m4.1)
```



scomposizione nel vettore delle varianze e matrice di correlazione
```{r 4.31}
diag(vcov(m4.1))
cov2cor(vcov(m4.1))
```
questi valori di correlazione sono molto piccoli, ne deduciamo che $\mu$ e $\sigma$ sono incorrelati


```{r 4.32}
post <- extract.samples(m4.1,n=1e4)
head(post)
```

```{r 4.33}
precis(post)
```


```{r 4.34}
post <- MASS::mvrnorm(n=1e4,mu=coef(m4.1),Sigma = vcov(m4.1))
```


```{r 4.35}
m4.1_logsigma <- map(
  alist(
    height~dnorm(mu,exp(log_sigma)),
    mu~dnorm(178,20),
    log_sigma~dnorm(2,10)
  ), data = d2
)
```


```{r 4.36}
post <- extract.samples(m4.1_logsigma)
sigma <- exp(post$log_sigma)
```

```{r 4.37}
plot(d2$height ~ d2$weight)
```


```{r 4.38}
m4.3 <- map(
  alist(
    
    height ~ dnorm(mu,sigma),
    mu <- a+b*weight,
    a ~ dnorm(156,100),
    b ~ dnorm(0,10),
    sigma ~ dunif(0,50)
  ),data = d2
)
```

```{r 4.40}
precis(m4.3)
```

```{r 4.41}
precis(m4.3, corr = TRUE)
```

```{r 4.42}
d2$weight.c <- d2$weight - mean(d2$weight)
```

```{r 4.43}
m4.4 <- map(
  alist(
    
    height ~ dnorm(mu,sigma),
    mu <- a+b*weight.c,
    a ~ dnorm(156,100),
    b ~ dnorm(0,10),
    sigma ~ dunif(0,50)
  ),data = d2
)
```


```{r 4.44}
precis(m4.4, corr = TRUE)
```
a è uguale al valore della media delle altezze, perchè con weight centrata uguali a 0, cioè con weight uguale alla sua media, ho le altezze uguali alla loro media. Cioè sono in un contesto **medio**

```{r 4.45}
plot(height ~ weight, data=d2,col=alpha("blue", 0.5))
abline(a = coef(m4.3)["a"],b =  coef(m4.3)["b"],col="red")
```

```{r 4.46}
post <- extract.samples(m4.3,n=1000) # estraggo 1000 campioni
plot(height ~ weight, data=d2,col=alpha("blue", 0.5))
for(i in 1:nrow(post)){
  abline(a = post[i,"a"], b = post[i,"b"],col=alpha("gray", 0.03))
}

abline(a = coef(m4.3)["a"],b =  coef(m4.3)["b"],col="red")
  
```

```{r 4.50}
mu_at_50 <- post$a + post$b*50
```

```{r 4.51}
dens(mu_at_50,col= rangi2,lwd=2, xlab= expression(" mu |x_i=50"))
```

```{r 4.52}
HPDI(mu_at_50)
```

```{r 4.53}
mu <- link(m4.3)
str(mu)
```

con la funzione *link* calcolo il valore del link nella distribuzioni a posteriori.

```{r 4.54}
weight.seq <- seq(from=25,to=70,by=1)

mu <- link(m4.3,data = data.frame(weight=weight.seq))
str(mu)
```

 
```{r 4.55}
plot(height~weight,d2)

for(i in 1:100){
  points(weight.seq,mu[i,],pch=16,col=col.alpha(rangi2,0.1))
}
```


```{r 4.56}
mu.mean <- apply(mu,2,mean)
mu.HPDI <- apply(mu,2,HPDI,prob=0.89)
```












































